#!/usr/bin/perl -w

use strict;
use JSON;
use Time::HiRes qw (sleep);
use Data::Dumper;
use Getopt::Long;
use lib './lib';
use Minecraft::Automation;
use Minecraft::Screenshoter;
use Minecraft::ItemsReader;
use Minecraft::UserInteraction;
use Minecraft::FileIO;
$main::config = Minecraft::FileIO::read_config();
my $seller = '';
my $buy = 'all';
my $target = 'sell';
my $current_trader_page = 1;
my $page_avialable_cache = {};
GetOptions(
    "seller=s" => \$seller,
    "buy=s"    => \$buy,
    "target=s" => \$target,
    "help"     => \&help
    ) or die("Что то не так с опциями командной строки\n");

sub help
{
  print <<_HELP_;
Использование: trade <options>
Опции:
    --target=строка Указывает приоритет торговли
        --target=sell приоритет выставляется на продажу. Покупки только для апгрейда торговца. Действует по умолчанию.
        --target=buy  приоритет выставляется на покупку. Продажи только для апгрейда торговца
    --buy=строка  Что можно купить (читайте что продают seller'ы выше)
            Указывайте через запятую, без пробелов
            Но есть еще две возможности:
              --buy=all скупает всё что есть (действие по умолчанию)
              --buy=none ничего не покупает
    --seller=строка  С кем надо торговать
          Доступно:
_HELP_
  for my $trader_file (Minecraft::FileIO::get_traders())
  {
      my $trader = Minecraft::FileIO::read_trader_file($trader_file);
      printf("\t\t%s\n\t\t\tПокупает: %s\n\t\t\tПродаёт: %s\n",
                  $trader->{'name'},
                  join(',', keys(%{$trader->{'sell'}})),
                  join(',', keys(%{$trader->{'buy'}})));
  }
  exit(0);
}

# ---------------------------------------------  навигация по страницам крестьянина ----------------------------------
sub switch_to_trader_page
{
    my $page = $_[0];
  my $button_name = $page > $current_trader_page ? 'next_page' : 'prev_page';
  while($page != $current_trader_page)
  {
    if(!trader_page_avialable($button_name, $current_trader_page))
    {
      return 0;
    }
    Minecraft::Automation::mouse_move_to_button($main::config->{'system'}{'villager'}{$button_name});
    Minecraft::Automation::mouse_left_click();
    sleep($main::config->{'user'}{'timeouts'}{'villager_page_switch'});
    $current_trader_page += $page > $current_trader_page ? 1 : -1;
  }
  return 1;

}

# ---------------------------------------------  обратная связь, скриншоты ----------------------------------
sub trader_can_sell
{
    return Minecraft::Screenshoter::compare_screenshots('dont-delete-villager-trade-avialable',
                            Minecraft::Screenshoter::take_temp_screenshot($main::config->{'system'}{'villager'}{'trade-avialable'}, 0));
}

sub trader_can_trade_on_page
{
  my $page = $_[0];
  if(switch_to_trader_page($page))
  {
    return trader_can_sell();
  }
  return 0;
}

sub trader_can_trade_something
{
  my $items_to_trade = $_[0];
  for my $item_to_trade (keys(%{$items_to_trade}))
  {
    if(trader_can_trade_on_page($items_to_trade->{$item_to_trade}))
    {
      return 1;
    }
  }
  return 0;
}

sub trader_can_trade_all
{
  my $items_to_trade = $_[0];
  my $flag = 0;
  for my $item_to_trade (keys(%{$items_to_trade}))
  {
    $flag += trader_can_trade_on_page($items_to_trade->{$item_to_trade});
  }
  return $flag == scalar(keys(%{$items_to_trade}));
}

sub trader_result_is_empty
{
  return Minecraft::Screenshoter::compare_screenshots('dont-delete-villager-result-empty',
                            Minecraft::Screenshoter::take_temp_screenshot($main::config->{'system'}{'villager'}{'result'}, 1));
}

sub trader_invertory_is_empty
{
  my $trader_invertory = $_[0];
  return Minecraft::Screenshoter::compare_screenshots(sprintf('dont-delete-villager-invertory-%d', $trader_invertory),
                            Minecraft::Screenshoter::take_temp_screenshot($main::config->{'system'}{'villager'}{'invertory'}{$trader_invertory}, 1));
}

sub trader_page_avialable
{
  my ($button_name, $page) = @_[0..1];
  if(!exists($page_avialable_cache->{$button_name}{$page}))
  {
    $page_avialable_cache->{$button_name}{$page} =
                !Minecraft::Screenshoter::compare_screenshots(sprintf("dont-delete-villager-%s-not-avialable", $button_name),
                          Minecraft::Screenshoter::take_temp_screenshot($main::config->{'system'}{'villager'}{$button_name}, 1));
  }
  return $page_avialable_cache->{$button_name}{$page};
}

sub trade_interface_is_open
{
  return Minecraft::Screenshoter::compare_screenshots('dont-delete-villager-clean',
                            Minecraft::Screenshoter::take_temp_screenshot($main::config->{'system'}{'villager'}{'clean'}, 0));
}

# ---------------------------------------------  элементы торговли ----------------------------------

sub wait_for_trader_upgrade
{
  my $items_to_trade = $_[0];
  Minecraft::UserInteraction::say("Отдыхаем, пока торговец апгредится...");
  Minecraft::Automation::close_interface('villager');
  sleep($main::config->{'user'}{'timeouts'}{'villager_upgrade'});
  Minecraft::Automation::open_interface('villager');
  $page_avialable_cache = {};
  $current_trader_page = 1;
  if(defined($items_to_trade))
  {
    Minecraft::UserInteraction::say("Проверяем, проапгредился ли торговец...");
    return trader_can_trade_something($items_to_trade);
  }
  return 1;
}

sub take_to_invertory_or_drop
{
  my ($cell, $invertory) = @_[0..1];
  if(Minecraft::ItemsReader::item_exists_in_invertory('empty', $invertory))
  {
    Minecraft::Automation::take_stack_to_invertory($cell);
    Minecraft::ItemsReader::remap_empty_cell_in_invertory($invertory);
  }
  else
  {
    Minecraft::Automation::drop_item_from_cell($cell);
  }
}

# --------------------------------------------- торговля с деревенскими ----------------------------------

sub trade_item_with_trader
{
  my ($item_to_trade, $trader_page, $trader_invertory, $invertory) = @_[0..3];
  my $done = 0;
  if(switch_to_trader_page($trader_page))
  {
    while(trader_can_sell() && Minecraft::ItemsReader::item_exists_in_invertory($item_to_trade, $invertory))
    {
      if(Minecraft::Screenshoter::hand_is_empty('villager'))
      {
        Minecraft::ItemsReader::put_stack_to_trader_invertory($item_to_trade, $trader_invertory, $invertory);
      }
      else
      {
        Minecraft::Automation::put_stack_to_cell($main::config->{'system'}{'villager'}{'invertory'}{$trader_invertory});
      }
      if(!trader_result_is_empty())
      {
        take_to_invertory_or_drop($main::config->{'system'}{'villager'}{'result'}, $invertory);
        $done = 1;
      }
    }
    Minecraft::UserInteraction::say("Забираем обратно остатки");
    if(!trader_invertory_is_empty($trader_invertory))
    {
      take_to_invertory_or_drop($main::config->{'system'}{'villager'}{'invertory'}{$trader_invertory}, $invertory);
    }
    if(!Minecraft::Screenshoter::hand_is_empty('villager'))
    {
      Minecraft::Automation::put_stack_to_cell($main::config->{'system'}{'villager'}{'invertory'}{$trader_invertory});
      take_to_invertory_or_drop($main::config->{'system'}{'villager'}{'invertory'}{$trader_invertory}, $invertory);
    }
  }
  return $done;
}

sub sell_to_trader
{
  my ($items_to_sell, $trader_invertory, $invertory) = @_[0..2];
  my @sell_pages;
  my $unchanged_invertory_dump = Dumper(%{$invertory});

  for my $item_to_sell (keys(%{$items_to_sell}))
  {
    Minecraft::UserInteraction::say("Продаём %s", $item_to_sell);
    if(trade_item_with_trader($item_to_sell, $items_to_sell->{$item_to_sell}, $trader_invertory, $invertory) && $target eq 'buy')
    {
      Minecraft::UserInteraction::say("Немного продали. Посмотрим, проапгредится ли продавец");
      last;
    }
  }
  if(  $target eq 'sell' &&
    $unchanged_invertory_dump ne Dumper(%{$invertory}) &&
    wait_for_trader_upgrade($items_to_sell))
  {
    Minecraft::ItemsReader::remap_empty_cell_in_invertory($invertory);
    return sell_to_trader($items_to_sell, $trader_invertory, $invertory);
  } else { Minecraft::UserInteraction::say("Продавать больше нечего"); }
  return $unchanged_invertory_dump eq Dumper(%{$invertory}) && trader_can_trade_all($items_to_sell);
}

sub buy_from_trader
{
  my ($items_to_buy, $trader_invertory, $invertory) = @_[0..2];
  my $unchanged_invertory_dump = Dumper(%{$invertory});
  for my $item_to_buy (keys(%{$items_to_buy}))
  {
    Minecraft::UserInteraction::say("Покупаем %s", $item_to_buy);
     if(trade_item_with_trader('emerald', $items_to_buy->{$item_to_buy}, $trader_invertory, $invertory) && $target eq 'sell')
    {
      Minecraft::UserInteraction::say("Немного купили. Посмотрим, проапгредится ли продавец");
      last;
    }
  }
  if(  $target eq 'buy' &&
    $unchanged_invertory_dump ne Dumper(%{$invertory}) &&
    wait_for_trader_upgrade($items_to_buy))
  {
    Minecraft::ItemsReader::remap_empty_cell_in_invertory($invertory);
    return buy_from_trader($items_to_buy, $trader_invertory, $invertory);
  }
  else { Minecraft::UserInteraction::say("Покупать больше нечего"); }
  return $unchanged_invertory_dump eq Dumper(%{$invertory}) && trader_can_trade_all($items_to_buy);
}

sub trade_with_trader
{
  my ($items_to_sell, $items_to_buy) = @_[0..1];
  my $invertory = Minecraft::ItemsReader::map_invertory( $items_to_sell );
  $items_to_sell = filter_sell($items_to_sell, $invertory);
  my $unchanged_invertory_dump = "";
  my $trader_invertory = 0;

  do
  {
    $unchanged_invertory_dump = Dumper(%{$invertory});
    for ($target)
    {
      if(/buy/)
      {
        if(!buy_from_trader($items_to_buy, $trader_invertory, $invertory))
        {
          sell_to_trader ($items_to_sell, $trader_invertory, $invertory);
        }
      }
      elsif(/sell/)
      {
        if(!sell_to_trader ($items_to_sell, $trader_invertory, $invertory))
        {
          buy_from_trader($items_to_buy, $trader_invertory, $invertory);
        }
      }
      else
      {
        Minecraft::UserInteraction::say("Вы неверно указали цель торговли. Читайте помощь.");
        help();
      }
    }
  }
  while($unchanged_invertory_dump ne Dumper(%{$invertory}) && wait_for_trader_upgrade());
  Minecraft::UserInteraction::say("Торговать больше нечем и не на что. Уходим.");
}

sub filter_sell
{
  my ($items_to_sell, $invertory) = @_[0..1];
  my $filtered_items_to_sell = {};
  for my $item_to_sell (keys(%{$items_to_sell}))
  {
    if(Minecraft::ItemsReader::item_exists_in_invertory($item_to_sell, $invertory))
    {
      $filtered_items_to_sell->{$item_to_sell} = $items_to_sell->{$item_to_sell};
    }
  }
  return $filtered_items_to_sell;
}

sub filter_buy
{
  my $items_to_buy = $_[0];
  if($buy eq 'all')
  {
    return $items_to_buy;
  }
  if($buy eq 'none')
  {
    return {};
  }
  my @user_buys = split(/,/, $buy);
  my $filtered_items_to_buy = {};
  for my $user_buy (@user_buys)
  {
    if(exists($items_to_buy->{$user_buy}))
    {
      $filtered_items_to_buy->{$user_buy} = $items_to_buy->{$user_buy};
    }
  }
  return $filtered_items_to_buy;
}

# ------------------------------------------- main -----------------------------------------------

for ($seller)
{
  my $traders = {};
  for my $trader_file (Minecraft::FileIO::get_traders())
  {
      my $trader = Minecraft::FileIO::read_trader_file($trader_file);
      $traders->{$trader->{'name'}} = $trader;
  }
  my $traders_names = join('|', keys(%{$traders}));
  if    (/$traders_names/)
  {
    trade_with_trader($traders->{$seller}{'sell'}, filter_buy($traders->{$seller}{'buy'}));
  }
  else { help(); }

}
