#!/usr/bin/perl -w

use strict;
use JSON;
use Time::HiRes qw (sleep);
use Data::Dumper;
use Getopt::Long;
use lib './lib';
use Minecraft::Automation;
use Minecraft::Screenshoter;
use Minecraft::ItemsReader;
use Minecraft::UserInteraction;
use Minecraft::FileIO;
use Minecraft::Interfaces::Villager;
$main::config = Minecraft::FileIO::read_config();
my $self_invertory = Minecraft::ItemsReader->new('villager', 'self-invertory');
my $villager = Minecraft::Interfaces::Villager->new();
my $seller = '';
my $buy = 'all';
my $target = 'sell';
my $current_trader_page = 1;
my $page_avialable_cache = {};
GetOptions(
    "seller=s" => \$seller,
    "buy=s"    => \$buy,
    "target=s" => \$target,
    "help"     => \&help
    ) or die("Что то не так с опциями командной строки\n");

sub help
{
  print <<_HELP_;
Использование: trade <options>
Опции:
    --target=строка Указывает приоритет торговли
        --target=sell приоритет выставляется на продажу. Покупки только для апгрейда торговца. Действует по умолчанию.
        --target=buy  приоритет выставляется на покупку. Продажи только для апгрейда торговца
    --buy=строка  Что можно купить (читайте что продают seller'ы выше)
            Указывайте через запятую, без пробелов
            Но есть еще две возможности:
              --buy=all скупает всё что есть (действие по умолчанию)
              --buy=none ничего не покупает
    --seller=строка  С кем надо торговать
          Доступно:
_HELP_
  for my $trader_file (Minecraft::FileIO::get_traders())
  {
      my $trader = Minecraft::FileIO::read_trader_file($trader_file);
      printf("\t\t%s\n\t\t\tПокупает: %s\n\t\t\tПродаёт: %s\n",
                  $trader->{'name'},
                  join(',', keys(%{$trader->{'sell'}})),
                  join(',', keys(%{$trader->{'buy'}})));
  }
  exit(0);
}


sub take_to_self_invertory_or_drop # take_to_invertory_or_drop
{
  my $cell = $_[0];
  if($self_invertory->empty_count())
  {
    Minecraft::Automation::take_stack_to_invertory($cell);
    $self_invertory->remap();
  }
  else
  {
    Minecraft::Automation::drop_item_from_cell($cell);
  }
}

sub trade_item_with_villager
{
  my ($item_to_trade, $trader_page, $villager_invertory) = @_[0..2];
  my $done = 0;
  if($villager->switch_to_page($trader_page))
  {
    while($villager->can_trade() && $self_invertory->item_exists($item_to_trade))
    {
      if($villager->hand_is_empty())
      {
        $self_invertory->take_stack_of_items($item_to_trade);
        $villager->put_stack_to_invertory($villager_invertory);
      }
      else
      {
        $villager->put_stack_to_invertory($villager_invertory);
      }
      if(!$villager->result_is_empty())
      {
        take_to_self_invertory_or_drop($main::config->{'system'}{'villager'}{'result'});
        $done = 1;
      }
    }
    Minecraft::UserInteraction::say("Забираем обратно остатки");
    if(!$villager->invertory_is_empty($villager_invertory))
    {
      take_to_self_invertory_or_drop($main::config->{'system'}{'villager'}{'invertory'}{$villager_invertory});
    }
    if(!$villager->hand_is_empty())
    {
      $villager->put_stack_to_invertory($villager_invertory);
      take_to_self_invertory_or_drop($main::config->{'system'}{'villager'}{'invertory'}{$villager_invertory});
    }
  }
  return $done;
}

sub sell_to_villager
{
  my ($items_to_sell, $villager_invertory) = @_[0..1];
  my @sell_pages;
  $self_invertory->save_state('before_sell');

  for my $item_to_sell (keys(%{$items_to_sell}))
  {
    Minecraft::UserInteraction::say("Продаём %s", $item_to_sell);
    if(trade_item_with_villager($item_to_sell, $items_to_sell->{$item_to_sell}, $villager_invertory) && $target eq 'buy')
    {
      Minecraft::UserInteraction::say("Немного продали. Посмотрим, проапгредится ли продавец");
      last;
    }
  }
  if(  
      $target eq 'sell' &&
      !$self_invertory->state_is_unchanged('before_sell') &&
      $villager->wait_for_upgrade($items_to_sell)
    )
  {
    $self_invertory->remap();
    return sell_to_villager($items_to_sell, $villager_invertory);
  } else { Minecraft::UserInteraction::say("Продавать больше нечего"); }
  return $self_invertory->state_is_unchanged('before_sell') && $villager->can_trade_all($items_to_sell);
}

sub buy_from_villager
{
  my ($items_to_buy, $villager_invertory) = @_[0..1];
  $self_invertory->save_state('before_buy');
  
  for my $item_to_buy (keys(%{$items_to_buy}))
  {
    Minecraft::UserInteraction::say("Покупаем %s", $item_to_buy);
     if(trade_item_with_villager('emerald', $items_to_buy->{$item_to_buy}, $villager_invertory) && $target eq 'sell')
    {
      Minecraft::UserInteraction::say("Немного купили. Посмотрим, проапгредится ли продавец");
      last;
    }
  }
  if(  
      $target eq 'buy' &&
      !$self_invertory->state_is_unchanged('before_buy') &&
      $villager->wait_for_upgrade($items_to_buy)
    )
  {
    $self_invertory->remap();
    return buy_from_villager($items_to_buy, $villager_invertory);
  }
  else { Minecraft::UserInteraction::say("Покупать больше нечего"); }
  return $self_invertory->state_is_unchanged('before_buy') && $villager->can_trade_all($items_to_buy);
}

sub trade_with_trader
{
  my ($items_to_sell, $items_to_buy) = @_[0..1];
  $self_invertory->add_items_to_items_to_find($items_to_sell);
  $self_invertory->map_cells();
  
  $items_to_sell = filter_sell($items_to_sell);
  my $unchanged_invertory_dump = "";
  my $villager_invertory = 0;

  do
  {
    $self_invertory->save_state('trade');
    for ($target)
    {
      if(/buy/)
      {
        if(!buy_from_villager($items_to_buy, $villager_invertory))
        {
          sell_to_villager ($items_to_sell, $villager_invertory);
        }
      }
      elsif(/sell/)
      {
        if(!sell_to_villager ($items_to_sell, $villager_invertory))
        {
          buy_from_villager($items_to_buy, $villager_invertory);
        }
      }
      else
      {
        Minecraft::UserInteraction::say("Вы неверно указали цель торговли. Читайте помощь.");
        help();
      }
    }
  }
  while(!$self_invertory->state_is_unchanged('trade') && $villager->wait_for_upgrade());
  Minecraft::UserInteraction::say("Торговать больше нечем и не на что. Уходим.");
}

sub filter_sell
{
  my ($items_to_sell) = $_[0];
  my $filtered_items_to_sell = {};
  for my $item_to_sell (keys(%{$items_to_sell}))
  {
    if($self_invertory->item_exists($item_to_sell))
    {
      $filtered_items_to_sell->{$item_to_sell} = $items_to_sell->{$item_to_sell};
    }
  }
  return $filtered_items_to_sell;
}

sub filter_buy
{
  my $items_to_buy = $_[0];
  if($buy eq 'all')
  {
    return $items_to_buy;
  }
  if($buy eq 'none')
  {
    return {};
  }
  my @user_buys = split(/,/, $buy);
  my $filtered_items_to_buy = {};
  for my $user_buy (@user_buys)
  {
    if(exists($items_to_buy->{$user_buy}))
    {
      $filtered_items_to_buy->{$user_buy} = $items_to_buy->{$user_buy};
    }
  }
  return $filtered_items_to_buy;
}

# ------------------------------------------- main -----------------------------------------------

for ($seller)
{
  my $traders = {};
  for my $trader_file (Minecraft::FileIO::get_traders())
  {
      my $trader = Minecraft::FileIO::read_trader_file($trader_file);
      $traders->{$trader->{'name'}} = $trader;
  }
  my $traders_names = join('|', keys(%{$traders}));
  if    (/$traders_names/)
  {
    trade_with_trader($traders->{$seller}{'sell'}, filter_buy($traders->{$seller}{'buy'}));
  }
  else { help(); }

}
